// Generated by CoffeeScript 2.5.1
(function() {
  var styles;

  styles = document.createElement('style');

  styles.innerText = '.yma-router-parked, .yma-hidden {display:none}';

  document.querySelector('head').append(styles);

  module.exports = {
    go: function() {
      return function(scope, elem, props) {
        var listener, scene;
        scope.$use('router');
        scene = scope.router.parsePath(props.go);
        listener = function(event) {
          return scope.router.go(scene.name, scene.data);
        };
        return scope.$addEventListeners(elem, 'mousedown', listener);
      };
    },
    hide: function(app) {
      return function(scope, elem, props) {
        if (props.hide && app.$eval(props.hide, scope)) {
          return app.$addClass(elem, 'yma-hidden');
        }
      };
    },
    "if": function(app) {
      return {
        pre: function(scope, elem, props) {
          console.log('if', props['if']);
          if (props["if"] && app.$eval(props["if"], scope)) {
            console.log(1);
            return [scope];
          } else {
            console.log(2);
            return [];
          }
        }
      };
    },
    press: function(app) {
      return function(scope, elem, props) {
        var listener;
        if (/\(/.test(props.press)) {
          listener = function(event) {
            scope.$event = event;
            app.$eval(props.press, scope);
            return delete scope.$event;
          };
        } else {
          listener = app.$eval(props.press, scope);
        }
        if (typeof listener === 'function') {
          return scope.$addEventListeners(elem, ['mousedown', 'click'], listener);
        }
      };
    },
    repeat: function(app) {
      var hashes;
      hashes = [];
      return {
        pre: function(scope, elem, props) {
          var arr, itemName, repeat, results;
          itemName = 'item';
          repeat = props.repeat;
          repeat = repeat.replace(/\sas\s([\w_]+)$/, function(all, name) {
            itemName = name;
            return '';
          });
          arr = app.$eval(repeat, scope);
          if (arr) {
            results = arr.map(function(item, i) {
              var hash, hashIndex, newscope;
              hash = app.$hash(JSON.stringify(item));
              hashIndex = hashes.indexOf(hash);
              newscope = app.Scope(scope);
              newscope[itemName] = item;
              newscope.$index = i;
              newscope.$first = i === 0;
              newscope.$last = i === arr.length - 1;
              newscope.$fresh = hashIndex === -1;
              newscope.$moveUp = hashIndex > i;
              newscope.$moveDown = hashIndex !== -1 && hashIndex < i;
              newscope.$lastIndex = hashIndex;
              //newscope.$dataid = app.$hash JSON.stringify app.$hashObject newscope
              return newscope;
            });
            if (scope.$phase === 'render') {
              hashes = results.map(function(scope) {
                return app.$hash(JSON.stringify(scope[itemName]));
              });
            }
            return results;
          } else {
            return [];
          }
        }
      };
    },
    controller: function(app) {
      return {
        pre: function(scope, elem, props) {
          var ctrl;
          ctrl = app.components[props.controller.toUpperCase()];
          if (ctrl) {
            ctrl.controller(scope);
          }
          return null;
        }
      };
    },
    router: function(app) {
      var bootstrapped, callbacks, checkScenePath, currentscene, go, parsePath, rendered, routerScope, scenes;
      callbacks = app.Callbacks();
      scenes = {};
      currentscene = null;
      routerScope = null;
      rendered = false;
      bootstrapped = false;
      checkScenePath = function(pathname, route) {
        var data, i, j, len, m, match, params, reg, regex;
        params = [];
        reg = route.replace(/:(\w+)/g, function(all, param) {
          params.push(param);
          return '([^/]+)';
        });
        regex = new RegExp('^' + reg + '$');
        data = {};
        if (m = pathname.match(regex)) {
          for (i = j = 0, len = m.length; j < len; i = ++j) {
            match = m[i];
            if (i === 0) {
              continue;
            }
            data[params[i - 1]] = match;
          }
          return data;
        } else {
          return null;
        }
      };
      parsePath = function(pathname) {
        var data, name, scene;
        for (name in scenes) {
          scene = scenes[name];
          if (data = checkScenePath(pathname, scene.route)) {
            return {
              name: scene.name,
              data: data
            };
          }
        }
      };
      go = async function(name, data, firstTime) {
        var e, j, len, nextscene, r, route, routes;
        if (currentscene.name === name && JSON.stringify(currentscene.data) === JSON.stringify(data) && !firstTime) {
          return;
        }
        nextscene = scenes[name];
        if (!nextscene) {
          return;
        }
        try {
          await callbacks.$call('sceneWillChange', {
            from: currentscene,
            to: nextscene
          });
        } catch (error) {
          e = error;
          if (e.redirect) {
            go(e.redirect);
          }
          return;
        }
        if (currentscene) {
          app.$removeClass(currentscene.scene, ['yma-router-active', 'yma-transition-in']);
          app.$addClass(currentscene.scene, ['yma-router-parked', 'yma-transition-out']);
          await app.$teardownChildren(app.$makeId(currentscene.scene));
        }
        await app.$teardownChildren(app.$makeId(nextscene.scene));
        currentscene = nextscene;
        currentscene.data = data || {};
        routerScope.data = data;
        if (nextscene.component) {
          nextscene.scene.innerHTML = '<' + nextscene.component + '>' + nextscene.html + '</' + nextscene.component + '>';
        } else {
          nextscene.scene.innerHTML = nextscene.html;
        }
        await app.$renderChildren(nextscene.scene, routerScope);
        app.$removeClass(nextscene.scene, ['yma-router-parked', 'yma-transition-out']);
        app.$addClass(nextscene.scene, ['yma-router-active', 'yma-transition-in']);
        routes = currentscene.route.replace(/:(\w+)/g, function(all, param) {
          var ref;
          return ((ref = currentscene.data[param]) != null ? ref.toString() : void 0) || all;
        }).split(/\|/g);
        route = '';
        for (j = 0, len = routes.length; j < len; j++) {
          r = routes[j];
          if (r.length > route.length && !/:/.test(r)) {
            route = r;
          }
        }
        if (route !== window.location.pathname) {
          return window.history.pushState(route, null, route);
        }
      };
      return {
        controller: function(scope, elem) {
          var firstTime;
          routerScope = scope;
          if (currentscene) {
            routerScope.data = currentscene.data;
          } else {
            scope.$on('bootstrap', function() {
              var data, j, len, params, props, ref, scene;
              if (bootstrapped) {
                return;
              }
              ref = elem.querySelectorAll('scene');
              for (j = 0, len = ref.length; j < len; j++) {
                scene = ref[j];
                props = app.$getProps(scene);
                props.scene = scene;
                props.html = scene.innerHTML;
                params = [];
                if (props.route) {
                  if (data = checkScenePath(props.route, window.location.pathname)) {
                    props.data = data;
                    scope.data = data;
                    currentscene = props;
                  }
                }
                scenes[props.name] = props;
                if ((typeof props.default !== 'undefined') && !currentscene) {
                  currentscene = props;
                }
                if (props.name === currentscene.name) {
                  currentscene = props;
                }
                scene.removeAttribute('route');
                app.$addClass(scene, 'yma-router-parked');
              }
              bootstrapped = true;
              if (rendered && bootstrapped) {
                return go(currentscene.name, currentscene.data, true);
              }
            });
          }
          firstTime = function() {
            if (!rendered) {
              rendered = true;
              if (rendered && bootstrapped) {
                go(currentscene.name, currentscene.data, true);
              }
            }
            return app.$off('rendered', firstTime);
          };
          app.$on('rendered', firstTime);
          return routerScope.$on('update', function() {
            var name, scene;
            for (name in scenes) {
              scene = scenes[name];
              scene.scene = elem.querySelector('scene[name="' + scene.name + '"]');
              app.$removeClass(scene.scene, 'yma-router-active');
              app.$addClass(scene.scene, 'yma-router-parked');
            }
            app.$removeClass(currentscene.scene, 'yma-router-parked');
            return app.$addClass(currentscene.scene, 'yma-router-active');
          });
        },
        service: function() {
          return {
            go: go,
            $on: callbacks.$on,
            parsePath: parsePath
          };
        }
      };
    },
    model: function(app) {
      return function(scope, elem, props) {
        var setValue, updateModel;
        setValue = function() {
          var value;
          if (elem.value !== app.$eval(props.model)) {
            value = app.$getScopeVar(props.model, scope);
            if (typeof value !== 'undefined') {
              return elem.value = value;
            }
          }
        };
        setValue();
        updateModel = function(event) {
          scope[props.model] = elem.value;
          app.$setScopeVar(props.model, elem.value, scope);
          return scope.$update();
        };
        scope.$addEventListeners(elem, ['keyup', 'change', 'paste', 'mouseup'], updateModel);
        return scope.$on('update', setValue);
      };
    },
    autofocus: function() {
      return function(scope, elem) {
        return elem.focus();
      };
    }
  };

}).call(this);

//# sourceMappingURL=main.js.map
